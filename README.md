# Анишка-Хакер
## Что я делаю?
У меня есть программа, которая требует требует пароль для доступа.

<image src="for_readme/prog1.png" width=250px><image src="for_readme/prog2.png" width=250px>

При неверно введенном пароле выводится:

<image src="for_readme/prog3.png" width=250px>

Моей задачей является взлом этой программы двумя способами:
<ul>
 <li>С помощью переполнения буфера</li>
 <li>С помощью замены байтов</li>
</ul>

## 1. Переполнение буфера
Для того, чтобы понять, что происходит в программе я использую TurboDebugger. 
Сначала вызываются четыре функции:

<image src="for_readme/dis1.png" width=300px>

Проанализировав, могу сказать, что первая функция рисует рамку на экран, а вторая - добавляет к ней текст. Нас это не особо интересует. Нам важнее две последние функции.

Предпоследняя функция занимается записью введенного пароля в память.

<image src="for_readme/dis2.png" width=300px>

<image src="for_readme/dis3.png" width=300px>

Как мы видим пароль записывается по ds:02F8 адресу буфера:

<image src="for_readme/dis4.png" width=300px>

Теперь разберем последнюю функцию. В ней вызывается хэш-функция, которая возращает хэш-сумму в регистре ax. Изучив ее получше, заметим, что она считает сумму ASCII-кодов каждого символа (это нам пригодится попозже).

<image src="for_readme/dis5.png" width=300px>

Далее эта сумма сравнивается с числом, которое лежит по адресу ds:0300-ds:0301:

<image src="for_readme/dis6.png" width=300px>

<image src="for_readme/dis7.png" width=300px>

Это число следует сразу после буфера с введенным паролем. Нужно просто вслед за паролем ввести его хэш-сумму!

Если я хочу, чтобы программа работала на пароль 'ANIbest!', то нужно вводить вместе с ее хеш-суммой: 'ANIbest!з':

<image src="for_readme/prog4.png" width=300px>

Юхуууу у нас все получилось!!

## 2. Замена байтов

### Что он делает?

С помощью этого проекта вы можете заменять определенные байты в файле(в нашем случае com-файле).
На основе этого реализуем взлом.

### Какой принцип работы?

Выше мы уже знали, в каком месте(в cs:025D) проверяется пароль:

<image src="for_readme/dis8.png" width=300px>

Если хэш-сумма верная, то происходит прыжок(на cs:026D). То есть для нашей цели программа заменяет все байты между этими адресами инструкциями nop (0x90).

В файле hack/hack.h можно выбрать на какие байты заменить, с какого адреса это делать и сколько символов переписать:
```
const char NOP_SYMB = 0x90;
const size_t PLACE_IN_FILE_TO_WRITE = 0x25D - 0x100; 
const size_t SYMBS_TO_WRITE_COUNT   = 15;
```
Это делает программу более универсальной.

### Как запустить программу?

Для сборки Makefile'a:
```
cmake CMakeLists.txt
```
Теперь у нас есть Makefile. Компилируем:
```
make
```
Команда для запуска программы:
```
./main.out <hackfile>
```
Вторым аргументом вводится путь до файла, который нужно взломать. Если его не вводить, то будет использоваться файл по-умолчанию.


### Как выглядит результат работы программы?

При запуске открывается окно загрузки:

<image src="for_readme/screen1.png" width=500px>

Далее появляется меню:

<image src="for_readme/screen2.png" width=500px>

Следуем инструкции на картинке и получаем:

<image src="for_readme/screen3.png" width=500px>

Проверим правдивость надписи на окне. Заходим в снова в TurboDebbuger. 

<image src="for_readme/dis9.png" width=300px>

Как мы видим байты действительно поменялись. Это то, что нам и было нужно. Теперь попробуем ввести любой пароль:

<image src="for_readme/prog4.png" width=300px>

У нас опять все вышло!!!
Для особо любопытных я спрятала пасхалку. Попробуй нажать чуть выше живота Лени)